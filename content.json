{"meta":{"title":"鲁西西杂货店","subtitle":null,"description":"鲁西西技术文档","author":"鲁西西","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2019-06-06T07:37:02.961Z","updated":"2019-06-06T07:37:02.961Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-06-06T07:36:33.521Z","updated":"2019-06-06T07:36:33.521Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"css-grid 布局","slug":"css/css-grid-布局","date":"2019-10-14T11:07:23.000Z","updated":"2019-10-15T07:09:15.852Z","comments":true,"path":"2019/10/14/css/css-grid-布局/","link":"","permalink":"http://yoursite.com/2019/10/14/css/css-grid-布局/","excerpt":"","text":"Grid布局在目前使用最多的布局方式是Flex布局，Flex布局是轴线布局，指定子元素在轴线上的位置，而Grid布局是将容器划分为”列“和”行“，产生单元格（cell），从而确定子元素的位置。 几个主要的属性html结构1234567891011&lt;div class=\"grid\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt;&lt;/div&gt; 公共css123.container &#123; display: grid;&#125; grid、inline-grid123.container &#123; display: grid; /* display: inlien-grid; */&#125; 设置行高 grid-template-rows | 设置列高 grid-template-columns12345.container &#123; display: grid; grid-template-rows: 100px 100px 100px; grid-template-columns： 100px 100px 100px;&#125; grid-template-rows 和 grid-template-columns都有很多属性： 固定值：100px repeat 以及auto-fill fr关键字 auto关键字 minmax()函数 固定值12345.contaner &#123; display: grid; grid-template-rows: 100px 100px 100px; grid-template-columns： 100px 100px 100px;&#125; images repeat函数上面的grid-template-rows: 100px 100px 100px;可以使用repeat函数代替；12345.contaner &#123; display: grid; grid-template-rows: repeat(3, 100px); grid-template-columns: repeat(3, 100px);&#125; auto-fill 是指尽可能容纳多的子元素，如果不能放下，那就自动换行。 images fr关键字表示单元格之间的比例关系。 12345.contaner &#123; display: grid; grid-template-rows: repeat(3, 100px); grid-template-columns: 1fr 1fr 2fr;&#125; images auto关键字12345.contaner &#123; display: grid; grid-template-rows: repeat(3, 100px); grid-template-columns: 50px 50px auto;&#125; 设置auto会自动计算撑满剩余空间，类似于flex布局flex：1。 minmax函数设置最小最大值 12345.contaner &#123; display: grid; grid-template-rows: repeat(3, 100px); grid-template-columns: 50px 50px minmax(50px, 100px);&#125; images grid-template-areas 划分区域1234567891011121314151617181920212223242526272829303132333435363738// html&lt;div class=\"container\"&gt; &lt;div class=\"item item-a\"&gt;&lt;/div&gt; &lt;div class=\"item item-b\"&gt;&lt;/div&gt; &lt;div class=\"item item-c\"&gt;&lt;/div&gt; &lt;div class=\"item item-d\"&gt;&lt;/div&gt;&lt;/div&gt;// css.container &#123; display: grid; width: 150px; height: 150px; grid-template-areas: \"a a a\" \"b c c\" \"b d d\"&#125;.item-a &#123; grid-area: a; background: red;&#125;.item-b &#123; grid-area: b; background: yellow;&#125;.item-c &#123; grid-area: c; background: blue;&#125;.item-d &#123; grid-area: d; background: green;&#125; images 很明显，grid-template-areas将单元格进行了分类，子元素通过grid-area进行了分类。但是行程的区域，必须是完整的矩形，否则无效。 grid-row-gap | grid-column-gap | grid-gap 设置单元格之间的间距设置间距较为简单，简写grid-gap: 10px 10px，第一个对应设置行间距，第二个值对应设置列间距。 images justify-items | align-items | place-items 设置单元格内容的对齐方式，上中下左中右。1234.container &#123; justify-items: start | center | end | stretch; align-items: start | center | end | stretch;&#125; images justify-items 和 align-items所决定的是单元格子元素在单元格的位置。 justify-content | align-content1234.container &#123; justify-content: start | center | end | stretch | space-around | space-between | space-evenly; align-content: start | center | end | stretch | space-around | space-between | space-evenly;&#125; justify-content 决定列在容器内的分布情况。 align-content 决定行在容器内的分布情况。 项目主要的属性 grid-column-start：左边框所在的垂直网格线 grid-column-end：右边框所在的垂直网格线 grid-row-start：上边框所在的水平网格线 grid-row-end：下边框所在的水平网格线 grid-row | grid-column： 缩写 grid-area: 设置项目的区域名 Grid所有属性 grid容器 grid项目 grid-template-columns（列宽） grid-column-end grid-template-rows（行高） grid-column-end grid-template-areas（命名网格） grid-row-start grid-template grid-row-end grid-column-gap（列间距） grid-column grid-row-gap（行间距） grid-row grid-gap grid-area justify-items（水平呈现方式） justify-self align-items（垂直呈现方式） align-self place-items （水平垂直呈现方式） place-self justify-content（水平分布方式） align-content（垂直方向的分布方式） place-content grid-auto-columns（隐式创建列大小） grid-auto-rows grid-auto-flow grid（网格布局）","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"布局","slug":"布局","permalink":"http://yoursite.com/tags/布局/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"egg-js jwt鉴权","slug":"egg/egg-js-jwt鉴权","date":"2019-10-12T09:36:15.000Z","updated":"2019-10-14T01:08:51.624Z","comments":true,"path":"2019/10/12/egg/egg-js-jwt鉴权/","link":"","permalink":"http://yoursite.com/2019/10/12/egg/egg-js-jwt鉴权/","excerpt":"","text":"jwtJson Web Token 简称为 JWT，它定义了一种用于简洁、自包含的用于通信双方之间以 JSON 对象的形式安全传递信息的方法。JWT 可以使用 HMAC 算法或者是 RSA 的公钥密钥对进行签名。 流程交互流程 images 生成tokenegg有egg-jwt的库，我这里用的是jsonwebtoken。 生成公钥和私钥 私钥 1openssl genrsa -out rsa_private_key.pem 1024 公钥 1openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem 生成token 12345678910111213141516// 获取tokengetAccessToken(data, expHours) &#123; const seconds = (new Date().getTime() / 1000); const exp = seconds + (expHours * 24 * 60 * 60); const cert = fs.readFileSync(path.join(__dirname, '../keys/rsa_private_key.pem')); const token = jwt.sign(&#123; data, exp &#125;, cert, &#123; algorithm: 'RS256' &#125;; return token;&#125;// 真实情况应该从数据库查询const data = &#123; username: 'zhangsan', userid: 123456 &#125;const token = getAccessToken(data, 5);// 将token存在redisapp.redis.set('userid', token); 鉴权auth中间件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const jwt = require('jsonwebtoken');const fs = require('fs');const path = require('path');module.exports = (options, app) =&gt; &#123; function verifyToken(token) &#123; const cert = fs.readFileSync(path.join(__dirname, '../keys/rsa_public_key.pem')); let res = &#123;&#125;; try &#123; const result = jwt.verify(token, cert, &#123; algorithms: [ 'RS256' ] &#125;) || &#123;&#125;; const &#123; exp &#125; = result; const now = Math.floor(Date.now() / 1000); if (now &lt;= exp) &#123; res = result.data || &#123;&#125;; &#125; &#125; catch (error) &#123; console.log(error); &#125; return res; &#125; return async function auth(ctx, next) &#123; const token = ctx.get('Authorization'); // const token = verifyToken(ctx.get('Authorization')); if (token) &#123; const result = verifyToken(token); const &#123; userid &#125; = result; if (userid) &#123; const redis_token = await app.redis.get(userid); if (token === redis_token) &#123; await next(); &#125; else &#123; ctx.body = new Error('您已经在其他设备登录，如果继续将清除其他设备登录状态'); &#125; &#125; else &#123; ctx.status = 401; ctx.body = new Error('您的登录状态已过期，请重新登录'); &#125; &#125; else &#123; ctx.status = 401; ctx.body = new Error('您还没有登录，请需登录后进行操作'); &#125; &#125;;&#125;","categories":[{"name":"Egg学习笔记","slug":"Egg学习笔记","permalink":"http://yoursite.com/categories/Egg学习笔记/"}],"tags":[{"name":"egg","slug":"egg","permalink":"http://yoursite.com/tags/egg/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"服务器","slug":"服务器","date":"2019-09-26T08:40:44.000Z","updated":"2019-10-14T02:23:32.719Z","comments":true,"path":"2019/09/26/服务器/","link":"","permalink":"http://yoursite.com/2019/09/26/服务器/","excerpt":"","text":"安装node12345678910111213yum install -y wgetwget https://nodejs.org/dist/v9.3.0/node-v9.3.0-linux-x64.tar.xzxz -d node-v9.3.0-linux-x64.tar.xztar -xf node-v9.3.0-linux-x64.tarln -s ~/node-v9.3.0-linux-x64/bin/node /usr/bin/nodeln -s ~/node-v9.3.0-linux-x64/bin/npm /usr/bin/npmln -s ~/node-v9.3.0-linux-x64/bin/npm /usr/bin/npx 安装版本管理n12npm i -g nln -s ~/node-v9.3.0-linux-x64/bin/npm /usr/bin/n","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://yoursite.com/categories/知识总结/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"centos","slug":"centos","permalink":"http://yoursite.com/tags/centos/"}]},{"title":"常用正则表达式","slug":"常用正则表达式","date":"2019-07-12T03:10:32.000Z","updated":"2019-10-09T15:04:38.102Z","comments":true,"path":"2019/07/12/常用正则表达式/","link":"","permalink":"http://yoursite.com/2019/07/12/常用正则表达式/","excerpt":"","text":"正则大全 ](https://img.shields.io/badge/状态-积极更新-673ab7.svg) ![](https://img.shields.io/badge/已收录-47条-4caf50.svg) ![ :whale:图形界面: https://any86.github.io/any-rule/ html注释1/&lt;!--(.*?)--&gt;$/ md5格式(32位)1/^[a-f0-9]&#123;32&#125;$/ 版本号格式必须为X.Y.Z1/^\\d+(\\.\\d+)&#123;2&#125;$/ 视频链接地址（视频格式可按需增删）1/^https?:\\/\\/.*?(swf|avi|flv|mpg|rm|mov|wav|asf|3gp|mkv|rmvb|mp4)$/i 图片链接地址（图片格式可按需增删）1/^https?:\\/\\/.*?(gif|png|jpg|jpeg|webp|svg|psd|bmp|tif)$/i 24小时制时间（HH:mm:ss）1/^((?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$)/ 12小时制时间（hh:mm:ss）1/^(1[0-2]|0?[1-9]):[0-5]\\d:[0-5]\\d$/ base64格式1/^\\s*data:([a-z]+\\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&amp;',()*+;=\\-._~:@\\/?%\\s]*?)\\s*$/i 数字/货币金额（支持负数、千分位分隔符）1/(^[-]?[1-9]\\d&#123;0,2&#125;($|(,\\d&#123;3&#125;)*($|(\\.\\d&#123;1,2&#125;$))))|((^[0](\\.\\d&#123;1,2&#125;)?)|(^[-][0]\\.\\d&#123;1,2&#125;))$/ 数字/货币金额 (只支持正数、不支持校验千分位分隔符)1/(^[1-9]([0-9]+)?(\\.[0-9]&#123;1,2&#125;)?$)|(^(0)&#123;1&#125;$)|(^[0-9]\\.[0-9]([0-9])?$)/ 银行卡号（16或19位）1/^([1-9]&#123;1&#125;)(\\d&#123;15&#125;|\\d&#123;18&#125;)$/ 中文姓名1/^([\\u4e00-\\u9fa5·]&#123;2,16&#125;)$/ 英文姓名1/(^[a-zA-Z]&#123;1&#125;[a-zA-Z\\s]&#123;0,20&#125;[a-zA-Z]&#123;1&#125;$)/ 新能源车牌号1/[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领 A-Z]&#123;1&#125;[A-HJ-NP-Z]&#123;1&#125;(([0-9]&#123;5&#125;[DF])|([DF][A-HJ-NP-Z0-9][0-9]&#123;4&#125;))$/ 非新能源车牌号1/^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领 A-Z]&#123;1&#125;[A-HJ-NP-Z]&#123;1&#125;[A-Z0-9]&#123;4&#125;[A-Z0-9挂学警港澳]&#123;1&#125;$/ 车牌号(新能源+非新能源)1/^([京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领 A-Z]&#123;1&#125;[A-HJ-NP-Z]&#123;1&#125;(([0-9]&#123;5&#125;[DF])|([DF]([A-HJ-NP-Z0-9])[0-9]&#123;4&#125;)))|([京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领 A-Z]&#123;1&#125;[A-Z]&#123;1&#125;[A-HJ-NP-Z0-9]&#123;4&#125;[A-HJ-NP-Z0-9 挂学警港澳]&#123;1&#125;)$/ URL链接(网址)1/^((https?|ftp|file):\\/\\/)?([\\da-z.-]+)\\.([a-z.]&#123;2,6&#125;)(\\/\\w\\.-]*)*\\/?/ 手机号(严谨), 根据工信部2019年最新公布的手机号段1/^1((3[\\d])|(4[5,6,7,9])|(5[0-3,5-9])|(6[5-7])|(7[0-8])|(8[\\d])|(9[1,8,9]))\\d&#123;8&#125;$/ 手机号(宽松), 只要是13,14,15,16,17,18,19开头即可1/^1[3-9]\\d&#123;9&#125;$/ 手机号(最宽松), 只要是1开头即可, 如果你的手机号是用来接收短信, 优先建议选择这一条1/^1\\d&#123;10&#125;$/ 日期, 如: 2000-01-01或2000-1-11/^\\d&#123;4&#125;(-)([0-1][0-2]|\\d)\\1([0-2]\\d|\\d|30|31)$/ email地址1/^[a-zA-Z0-9.!#$%&amp;'*+\\/=?^_`&#123;|&#125;~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]&#123;0,61&#125;[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]&#123;0,61&#125;[a-zA-Z0-9])?)*$/ 国内座机电话,如: 0341-860912341/\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;/ 一代身份证号(15位数字)1/^\\d&#123;8&#125;(0\\d|10|11|12)([0-2]\\d|30|31)\\d&#123;3&#125;$/ 二代身份证号(18位数字),最后一位是校验位,可能为数字或字符X1/^\\d&#123;6&#125;(18|19|20)\\d&#123;2&#125;(0\\d|10|11|12)([0-2]\\d|30|31)\\d&#123;3&#125;(\\d|X|x)$/ 身份证号, 支持1/2代(15位/18位数字)1/(^\\d&#123;8&#125;(0\\d|10|11|12)([0-2]\\d|30|31)\\d&#123;3&#125;$)|(^\\d&#123;6&#125;(18|19|20)\\d&#123;2&#125;(0\\d|10|11|12)([0-2]\\d|30|31)\\d&#123;3&#125;(\\d|X|x)$)/ 护照（包含香港、澳门）1/(^[EeKkGgDdSsPpHh]\\d&#123;8&#125;$)|(^(([Ee][a-fA-F])|([DdSsPp][Ee])|([Kk][Jj])|([Mm][Aa])|(1[45]))\\d&#123;7&#125;$)/ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线组合1/^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$/ 纯中文/汉字1/^[\\u4E00-\\u9FA5]+$/ 是否小数1/^\\d+\\.\\d+$/ 电话(座机)1/^0\\d&#123;2,3&#125;-\\d&#123;7,8&#125;$/ 纯数字1/^\\d&#123;1,&#125;$/ 是否html标签1/&lt;(.*)&gt;.*&lt;\\/\\1&gt;|&lt;(.*) \\/&gt;/ 是否qq号格式正确1/^[1-9][0-9]&#123;4,10&#125;$/ 是否由数字和字母组成1/^[A-Za-z0-9]+$/ 纯英文字母1/^[a-zA-Z]+$/ 纯小写英文字母组成1/^[a-z]+$/ 纯大写英文字母1/^[A-Z]+$/ 密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符1/^.*(?=.&#123;6,&#125;)(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&amp;*? ]).*$/ 用户名正则，4到16位（字母，数字，下划线，减号）1/^[a-zA-Z0-9_-]&#123;4,16&#125;$/ ip-v41/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/ ip-v61/^((([0-9A-Fa-f]&#123;1,4&#125;:)&#123;7&#125;[0-9A-Fa-f]&#123;1,4&#125;)|(([0-9A-Fa-f]&#123;1,4&#125;:)&#123;6&#125;:[0-9A-Fa-f]&#123;1,4&#125;)|(([0-9A-Fa-f]&#123;1,4&#125;:)&#123;5&#125;:([0-9A-Fa-f]&#123;1,4&#125;:)?[0-9A-Fa-f]&#123;1,4&#125;)|(([0-9A-Fa-f]&#123;1,4&#125;:)&#123;4&#125;:([0-9A-Fa-f]&#123;1,4&#125;:)&#123;0,2&#125;[0-9A-Fa-f]&#123;1,4&#125;)|(([0-9A-Fa-f]&#123;1,4&#125;:)&#123;3&#125;:([0-9A-Fa-f]&#123;1,4&#125;:)&#123;0,3&#125;[0-9A-Fa-f]&#123;1,4&#125;)|(([0-9A-Fa-f]&#123;1,4&#125;:)&#123;2&#125;:([0-9A-Fa-f]&#123;1,4&#125;:)&#123;0,4&#125;[0-9A-Fa-f]&#123;1,4&#125;)|(([0-9A-Fa-f]&#123;1,4&#125;:)&#123;6&#125;((\\b((25[0-5])|(1\\d&#123;2&#125;)|(2[0-4]\\d)|(\\d&#123;1,2&#125;))\\b)\\.)&#123;3&#125;(\\b((25[0-5])|(1\\d&#123;2&#125;)|(2[0-4]\\d)|(\\d&#123;1,2&#125;))\\b))|(([0-9A-Fa-f]&#123;1,4&#125;:)&#123;0,5&#125;:((\\b((25[0-5])|(1\\d&#123;2&#125;)|(2[0-4]\\d)|(\\d&#123;1,2&#125;))\\b)\\.)&#123;3&#125;(\\b((25[0-5])|(1\\d&#123;2&#125;)|(2[0-4]\\d)|(\\d&#123;1,2&#125;))\\b))|(::([0-9A-Fa-f]&#123;1,4&#125;:)&#123;0,5&#125;((\\b((25[0-5])|(1\\d&#123;2&#125;)|(2[0-4]\\d)|(\\d&#123;1,2&#125;))\\b)\\.)&#123;3&#125;(\\b((25[0-5])|(1\\d&#123;2&#125;)|(2[0-4]\\d)|(\\d&#123;1,2&#125;))\\b))|([0-9A-Fa-f]&#123;1,4&#125;::([0-9A-Fa-f]&#123;1,4&#125;:)&#123;0,5&#125;[0-9A-Fa-f]&#123;1,4&#125;)|(::([0-9A-Fa-f]&#123;1,4&#125;:)&#123;0,6&#125;[0-9A-Fa-f]&#123;1,4&#125;)|(([0-9A-Fa-f]&#123;1,4&#125;:)&#123;1,7&#125;:))$/i 16进制颜色1/^#?([a-fA-F0-9]&#123;6&#125;|[a-fA-F0-9]&#123;3&#125;)$/ 微信号，6至20位，以字母开头，字母，数字，减号，下划线1/^[a-zA-Z][-_a-zA-Z0-9]&#123;5,19&#125;$/ 中国邮政编码1/^(0[1-7]|1[0-356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[0-5]|8[013-6])\\d&#123;4&#125;$/ 只包含中文和数字1/^(([\\u4E00-\\u9FA5])|(\\d))+$/ 非字母1/[^A-Za-z]$/","categories":[{"name":"知识总结","slug":"知识总结","permalink":"http://yoursite.com/categories/知识总结/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"Flutter 屏幕适配","slug":"flutter/Flutter-屏幕适配","date":"2019-06-20T05:18:53.000Z","updated":"2019-06-20T05:20:29.425Z","comments":true,"path":"2019/06/20/flutter/Flutter-屏幕适配/","link":"","permalink":"http://yoursite.com/2019/06/20/flutter/Flutter-屏幕适配/","excerpt":"","text":"flutter适配有三种方式： 使用Scallfold SafeArea Widget MeidaQuery 使用Scallfold1234567891011121314151617class MyApp extends StateLessWidget &#123; @override Widget build(BuildConext context) &#123; retutu MaterialApp( title: 'SafeArea 适配', home: scallfold( appBar: AppBar( ... ), bottomNavigationBar:BottomNavigationBar( items: [], ... ), ) ) &#125;&#125; SafeArea Widget1234567891011class MyApp extends StateLessWidget &#123; @override Widget build(BuildConext context) &#123; retutu MaterialApp( title: 'SafeArea 适配' home: SafeArea( child: ..., ), ) &#125;&#125; MeidaQuery1234567891011121314151617181920212223import 'package:flutter/material.dart';class Test extends StatelessWidget &#123; const Test(&#123;Key key&#125;) : super(key: key); @override Widget build(BuildContext context) &#123; return MaterialApp( home: HomePage(), ); &#125;&#125;class HomePage extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; final EdgeInsets edgeInsets = MediaQuery.of(context).padding; // TODO: implement build return Container( padding: EdgeInsets.fromLTRB(0, edgeInsets.top, 0, edgeInsets.bottom), ); &#125;&#125; 以上三种方式均可达到ios全面屏的适配。 安卓可以在/android/app/src/main/AndroidManifest.xml下增加如下代码： 1234&lt;meta-data android:name=&quot;android.max_aspect&quot; android:value=&quot;2.3&quot; /&gt; 如遇到需要适配字体大小或者Container长宽等，可用插件去适配 可查看以下博客：https://www.cnblogs.com/ckAng/p/10077832.html","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/categories/Flutter/"}],"tags":[{"name":"移动端 Flutter","slug":"移动端-Flutter","permalink":"http://yoursite.com/tags/移动端-Flutter/"}]},{"title":"规则底部导航栏","slug":"flutter/规则底部导航栏","date":"2019-06-06T10:33:42.000Z","updated":"2019-06-06T11:01:10.075Z","comments":true,"path":"2019/06/06/flutter/规则底部导航栏/","link":"","permalink":"http://yoursite.com/2019/06/06/flutter/规则底部导航栏/","excerpt":"","text":"底部导航栏在我们常见的APP当中，基本都会有，那我们来看是如何进行开发的，完整demo如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import 'package:flutter/material.dart';import './pages/home_page.dart';import './pages/all_page.dart';import './pages/me_page.dart';class MyBottomNavigation extends StatefulWidget &#123; _MyBottomNavigationState createState() =&gt; _MyBottomNavigationState();&#125;class _MyBottomNavigationState extends State&lt;MyBottomNavigation&gt; &#123; final _defaultColot = Colors.grey[400]; final _activeColor = Colors.blueAccent; int _currentIndex = 0; @override List&lt;Widget&gt; _pages = new List(); void initState() &#123; _pages ..add(HomePage()) ..add(AllPage()) ..add(MePage()); super.initState(); &#125; @override Widget build(BuildContext context) &#123; return Scaffold( body: _pages[_currentIndex], bottomNavigationBar: BottomNavigationBar( items: [ BottomNavigationBarItem( icon: Icon(Icons.home,), title: Text('One',) ), BottomNavigationBarItem( icon: Icon(Icons.border_all,), title: Text('All') ), BottomNavigationBarItem( icon: Icon(Icons.person), title: Text('Me') ), ], currentIndex: _currentIndex, selectedItemColor: _activeColor, unselectedItemColor: _defaultColot, onTap: (int index) &#123; this.setState(() &#123; _currentIndex = index; &#125;); &#125;, ), ); &#125;&#125; BottomNavigationBar 构造函数如下：12345678910111213141516BottomNavigationBar(&#123; Key key, @required this.items, this.onTap, this.currentIndex = 0, this.elevation = 8.0, BottomNavigationBarType type, Color fixedColor, this.backgroundColor, this.iconSize = 24.0, Color selectedItemColor, this.unselectedItemColor, this.selectedFontSize = 14.0, this.unselectedFontSize = 12.0, this.showSelectedLabels = true, bool showUnselectedLabels, 参数 参数类型 参数意义 key Key Widget 标识 items List 导航列表 backgroundColor Color 背景颜色 action SnackBarAction SnackBar按钮 duration Duration 停留时间 animation Animation 显示和消失动画","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/tags/Flutter/"},{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"}]},{"title":"关于js Event loop和任务队列的一点理解","slug":"前端知识集锦/关于js-Event-loop和任务队列的一点理解","date":"2019-06-06T07:45:14.000Z","updated":"2019-06-06T10:34:03.231Z","comments":true,"path":"2019/06/06/前端知识集锦/关于js-Event-loop和任务队列的一点理解/","link":"","permalink":"http://yoursite.com/2019/06/06/前端知识集锦/关于js-Event-loop和任务队列的一点理解/","excerpt":"","text":"之前在掘金上面看到很多文章都在说Event loop和事件队列，一直没有弄得很明白，直到最近几天，一个后端同学问到一个关于事件循环的问题，发现自己根本没有搞清楚，于是找了些文章，有了一些理解，在这里记录下，加深对其的理解。 首先我们来看一道题目： 1234567891011121314console.log('script start'); setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2');&#125;)console.log('script end'); 如果对Event loop很熟悉的话，那这个自然不在话下，但是如果理解不到位的话，那可能会出一点小差错，你对了吗？ 下面我们一起来看答案是什么，这里介绍两个概念：宏任务和微任务。 宏任务和微任务 宏任务：包括script（整体代码）、I/O、 微任务：包括定期器、网络请求、Promise.then 当函数执行栈为空的时候，去轮询事件队列，发现有事件，就拿出来执行。当遇到异步任务，比如定期器、网络请求、Promise的等都会交给异步处理模块，一旦异步函数到达其触发条件，比如定时器到时、异步请求返回时，异步处理模块将其回调函数按照类型打包压入任务队列，这个就是微任务队列。不断轮训事件队列就是事件循环（Event loop）。当所有的宏任务都执行完毕后，会去处理微任务队列。 images 那我们回过头在继续看上面的题目， 1234567891011121314console.log('script start'); // 被加入到宏任务队列setTimeout(function() &#123; // 0毫秒后，回调函数被加入到微任务队列 console.log('setTimeout');&#125;, 0);new Promise(function(resolve) &#123; // Promise 是宏任务，被加入到宏任务 console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2'); // resolve()执行之后，加入到微任务队列&#125;)console.log('script end'); // 被加入到宏任务队列 所以就会打印出12345script startpromise1script endpromise2setTimeout 为什么Promise.then回调要比setTimeout回调先执行？是因为setTimeout是只在主线程最空闲的情况下，经过一定时间去执行回调函数，所以setTimeout会被放到任务队列的最后一个，所以最晚执行。 总结 事件循环（Event loop）：不断从事件队列取出任务执行的过程； 事件队列：宏任务和微任务构成的队列；","categories":[],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"},{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"}]},{"title":"前端知识-2019-6-4","slug":"面试题库/2019-6-4","date":"2019-06-04T10:14:19.000Z","updated":"2019-09-26T08:40:05.332Z","comments":true,"path":"2019/06/04/面试题库/2019-6-4/","link":"","permalink":"http://yoursite.com/2019/06/04/面试题库/2019-6-4/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/tags/前端知识/"}]},{"title":"构建base Image","slug":"docker/Docker学习笔记-构建base-Image","date":"2019-04-03T04:55:12.000Z","updated":"2019-06-04T10:11:14.874Z","comments":true,"path":"2019/04/03/docker/Docker学习笔记-构建base-Image/","link":"","permalink":"http://yoursite.com/2019/04/03/docker/Docker学习笔记-构建base-Image/","excerpt":"","text":"1.创建hello.js 1console.log(&apos;hello&apos;) 2.创建Dockerfile 123FROM scratch // scratch代表没有baseImageADD hello.js / // 添加到根目录CMD [&quot; node hello.js &quot;] // 执行命令 3.运行build命令 1docker build -t xxx . // -t 表示tag xxx是tag名，.必不可少，表示在当前目录找Dockerfile 如果执行build命令执行成功，则构建成功，可以用dockcer image ls查看。","categories":[{"name":"Docker学习","slug":"Docker学习","permalink":"http://yoursite.com/categories/Docker学习/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"egg-sequelize","slug":"egg/egg-sequelize","date":"2019-03-15T00:10:24.000Z","updated":"2019-06-06T06:55:51.854Z","comments":true,"path":"2019/03/15/egg/egg-sequelize/","link":"","permalink":"http://yoursite.com/2019/03/15/egg/egg-sequelize/","excerpt":"","text":"egg-sequelize在大型应用中，我们可能需要ORM框架来帮助我们管理数据层面工具，而sequelize在node社区中被广泛使用。它支持MySql,PostgreSQL,SQLite,MSSQL等多个数据源。 下面用demo演示如何利用egg-sequelize进行CRUD操作。 初始化项目 12egg-init --type=simple sequelize-demonpm i 配置config（config/config.default.js） 12345678config.sequelize = &#123; port: 3306, dialect: &apos;mysql&apos;, host: &apos;localhost&apos;, database: &apos;miao&apos;, username: &apos;root&apos;, password: &apos;123456&apos;,&#125; 配置插件 plugin.js（config/plugin.js） 1234exports.sequelize = &#123; enable: true, package: ‘egg-sequelize’&#125; 安装egg-sequelize, sequelize-cli, mysql2 1npm i egg-sequelize sequelize-cli mysql2 sequelize配置文件 .sequelizerc 123456789&apos;use strict&apos;;const path = require(&apos;path&apos;);module.exports = &#123; config: path.join(__dirname, &apos;database/config.json&apos;), &apos;migrations-path&apos;: path.join(__dirname, &apos;database/migrations&apos;), // 用来控制数据库迁移的文件夹，需要修改表结构的时候，可以通过代码来控制数据库表结构的版本回退 &apos;seeders-path&apos;: path.join(__dirname, &apos;database/seeders&apos;), // 是存放如何生成假数据的文件夹 &apos;models-path&apos;: path.join(__dirname, &apos;app/models&apos;), // 是表中字段硬度和到JS对象中的逻辑，在controller中和service中可通过this.app.model或者this.ctx.model访问&#125; 初始化 12npx sequelize init:config (生成database目录和配置文件config.json)npx sequelize init:migrations(生成database目录和子目录migrations) 123456789101112131415161718192021222324// config.json&#123; &quot;development&quot;: &#123; &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: &quot;123456&quot;, &quot;database&quot;: &quot;miao&quot;, &quot;host&quot;: &quot;localhost&quot;, &quot;dialect&quot;: &quot;mysql&quot; &#125;, &quot;test&quot;: &#123; &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: &quot;123456&quot;, &quot;database&quot;: &quot;miao&quot;, &quot;host&quot;: &quot;localhost&quot;, &quot;dialect&quot;: &quot;mysql&quot; &#125;, &quot;production&quot;: &#123; &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: &quot;123456&quot;, &quot;database&quot;: &quot;miao&quot;, &quot;host&quot;: &quot;localhost&quot;, &quot;dialect&quot;: &quot;mysql&quot; &#125;&#125; 初始化user表npx sequelize migration:generate --name=init-users, 会在migration生成一个migration 文件(${timestamp}-init-users.js) 12345678910111213141516171819&apos;use strict&apos;;module.exports = &#123; // 在执行数据库升级时调用的函数，创建 users 表 up: async (queryInterface, Sequelize) =&gt; &#123; const &#123; INTEGER, DATE, STRING &#125; = Sequelize; await queryInterface.createTable(&apos;users&apos;, &#123; id: &#123; type: INTEGER, primaryKey: true, autoIncrement: true &#125;, name: STRING(30), age: INTEGER, created_at: DATE, updated_at: DATE, &#125;); &#125;, // 在执行数据库降级时调用的函数，删除 users 表 down: async queryInterface =&gt; &#123; await queryInterface.dropTable(&apos;users&apos;); &#125;,&#125;; 升级数据库npx sequelize db:megrate 1234# 如果有问题需要回滚，可以通过 `db:migrate:undo` 回退一个变更# npx sequelize db:migrate:undo# 可以通过 `db:migrate:undo:all` 回退到初始状态# npx sequelize db:migrate:undo:all 创建model 12345678910111213141516// app/models/user.js&apos;use strict&apos;;module.exports = app =&gt; &#123; const &#123; STRING, INTEGER, DATE &#125; = app.Sequelize; const User = app.model.define(&apos;user&apos;, &#123; id: &#123; type: INTEGER, primaryKey: true, autoIncrement: true &#125;, name: STRING(30), age: INTEGER, created_at: DATE, updated_at: DATE, &#125;); return User;&#125;; 这样就可以在app.model.User或者 ctx.model.User上访问User。12345678910111213141516171819202122232425262728293031323334353637383940414243444546// service/user.js&apos;use strict&apos;;const Service = require(&apos;egg&apos;).Service;class User extends Service &#123; async list(&#123; offset = 0, limit = 10 &#125;) &#123; return this.ctx.model.User.findAndCountAll(&#123; offset, limit, order: [[ &apos;created_at&apos;, &apos;desc&apos; ], [ &apos;id&apos;, &apos;desc&apos; ]], &#125;); &#125; // 查找 async find(id) &#123; const user = await this.ctx.model.User.findById(id); if (!user) &#123; this.ctx.throw(404, &apos;user not found&apos;); &#125; return user; &#125; // 创建 async create(user) &#123; return this.ctx.model.User.create(user); &#125; // 更新 async update(&#123; id, updates &#125;) &#123; const user = await this.ctx.model.User.findById(id); if (!user) &#123; this.ctx.throw(404, &apos;user not found&apos;); &#125; return user.update(updates); &#125; // 删除 async del(id) &#123; const user = await this.ctx.model.User.findById(id); if (!user) &#123; this.ctx.throw(404, &apos;user not found&apos;); &#125; return user.destroy(); &#125;&#125;module.exports = User;","categories":[{"name":"Egg学习笔记","slug":"Egg学习笔记","permalink":"http://yoursite.com/categories/Egg学习笔记/"}],"tags":[{"name":"egg","slug":"egg","permalink":"http://yoursite.com/tags/egg/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"sequelize","slug":"sequelize","permalink":"http://yoursite.com/tags/sequelize/"}]},{"title":"Sequelize 创建数据库表","slug":"egg/sequelize/Sequelize","date":"2019-03-14T23:32:01.000Z","updated":"2019-06-06T06:55:32.850Z","comments":true,"path":"2019/03/15/egg/sequelize/Sequelize/","link":"","permalink":"http://yoursite.com/2019/03/15/egg/sequelize/Sequelize/","excerpt":"","text":"Sequelize类型Sequelize类型有很多，详情DataType。其中常用的有 STRING, TEXT, INTEGER, FLOAT, DOUBLE, DATE等。 环境搭建 创建数据库test_sequelize 1CREATE DATABASE test_sequelize DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; 创建文件夹sequelize，执行npm init; cd sequelize,并执行npm i sequelize mysql2; 创建以下文件夹 app/model app/db app/utils \b创建连接1234567891011121314151617181920212223242526// db/index.jsconst Sequelize = requeire(&apos;sequelize&apos;);const dbconfig = &#123; username: &apos;root&apos;, // mysql用户名 password: &apos;root&apos;, // mysql 密码 database: &apos;sequelize_test&apos;, // 数据库名 port: 3306, host: &apos;localhost&apos;, dialect: &apos;mysql&apos; // &apos;mysql&apos;|&apos;sqlite&apos;|&apos;postgres&apos;|&apos;mssql&apos;&#125;const &#123; username, password, database, port, host, dialect &#125; = dbconfig;const db = new Sequelize(database, username, password, &#123; host, port, dialect, pool: &#123; max: 5, min: 0, idle: 100000 &#125;, timezone: &apos;+08:00&apos; // 时区&#125;)module.exports = db; ### 创建表12345678910111213141516171819202122232425const Sequelize = requeire(&apos;sequelize&apos;);const &#123; STRING, INTEGER &#125; = Sequelize;const db = require(&apos;../db&apos;);const User = db.define(&apos;user&apos;, &#123; // 表名 userId: &#123; type: INTEGER &#125;, userName: &#123; type: STRING &#125;, password: &#123; type: STRING &#125;,&#125;)const createTable = () =&gt; &#123; await User.sync(&#123; force: false // 设置为true，则先删除在创建 &#125;)&#125;(async () =&gt; &#123; await createTable()&#125;)()","categories":[{"name":"Egg学习笔记","slug":"Egg学习笔记","permalink":"http://yoursite.com/categories/Egg学习笔记/"}],"tags":[{"name":"egg","slug":"egg","permalink":"http://yoursite.com/tags/egg/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"sequelize","slug":"sequelize","permalink":"http://yoursite.com/tags/sequelize/"}]},{"title":"Flutter介绍","slug":"flutter/Flutter介绍","date":"2019-01-31T10:10:06.000Z","updated":"2019-06-04T10:24:58.430Z","comments":true,"path":"2019/01/31/flutter/Flutter介绍/","link":"","permalink":"http://yoursite.com/2019/01/31/flutter/Flutter介绍/","excerpt":"","text":"1.移动开发技术简介移动开发技术简介 2.Flutter简介Flutter是谷歌公司推出的一个移动应用开发框架，主要有跨平台、高保真、高性能等优点。基于dart语言开发，可以一套代码分别运行在IOS和Android平台上。Flutter有丰富的组件\b和接口。 3.资源 官网 Flutter中文网 4.搭建开发环境https://book.flutterchina.club/chapter1/install_flutter.html","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/categories/Flutter/"}],"tags":[{"name":"移动端 Flutter","slug":"移动端-Flutter","permalink":"http://yoursite.com/tags/移动端-Flutter/"}]},{"title":"Electron[第一个Electron应用","slug":"electron/Electron-第一个Electron应用","date":"2018-12-21T13:05:40.000Z","updated":"2018-12-21T13:05:45.062Z","comments":true,"path":"2018/12/21/electron/Electron-第一个Electron应用/","link":"","permalink":"http://yoursite.com/2018/12/21/electron/Electron-第一个Electron应用/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Electron快速开始","slug":"electron/Electron[快速开始]","date":"2018-12-21T12:15:01.000Z","updated":"2018-12-25T08:58:33.892Z","comments":true,"path":"2018/12/21/electron/Electron[快速开始]/","link":"","permalink":"http://yoursite.com/2018/12/21/electron/Electron[快速开始]/","excerpt":"","text":"Electron 介绍 比你想象的更简单—对于前端人员，electron可以帮助其构建桌面应用，Electron文档上写道，只要你会写html，css，js就可以，剩下的事情交给Electron去做 快速开始12345git clone https://github.com/electron/electron-quick-startcd electron-quick-start npm install &amp; npm start 这个时候你就应该可以看到一个hello world","categories":[{"name":"Electron学习","slug":"Electron学习","permalink":"http://yoursite.com/categories/Electron学习/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"http://yoursite.com/tags/Electron/"}]},{"title":"Docker学习笔记-镜像","slug":"docker/Docker学习笔记-镜像","date":"2018-12-16T10:35:59.000Z","updated":"2019-06-04T11:24:29.701Z","comments":true,"path":"2018/12/16/docker/Docker学习笔记-镜像/","link":"","permalink":"http://yoursite.com/2018/12/16/docker/Docker学习笔记-镜像/","excerpt":"","text":"镜像 获取镜像 Docker Hub为开发者提供了数十万的镜像，可以为大家下载 可以通过 docker pull [NAME]:[TAG], TAG如果不指定的话，会默认去拉取tag为latest的镜像，也就是最新版, docker pull可以修改下载仓库，切换到自己的私有仓库， 1docker pull xxx(私有仓库地址) docker pull 子命令 1docker pull -a --all-tags=true | false 查看镜像信息 docker images images REPOSITORY: 镜像来自于哪个仓库 TAG: 镜像标签信息 IMAGE ID: 镜像唯一ID CREATED: 创建时间，最后更新时间 SIZE: 镜像大小(一般来说，越小越好) 发布一个镜像","categories":[{"name":"Docker学习","slug":"Docker学习","permalink":"http://yoursite.com/categories/Docker学习/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"Docker学习系列笔记[docker常用命令]","slug":"docker/Docker学习系列笔记-docker常用命令","date":"2018-12-14T04:01:44.000Z","updated":"2018-12-21T12:12:05.083Z","comments":true,"path":"2018/12/14/docker/Docker学习系列笔记-docker常用命令/","link":"","permalink":"http://yoursite.com/2018/12/14/docker/Docker学习系列笔记-docker常用命令/","excerpt":"","text":"#查看当前docker版本docker -v #查看当前本地所有镜像docker images #构造镜像,用法docker build -t 镜像名称 .docker build -t docker_demo . #用于容器与主机之间的数据拷贝。用法docker cp 主机文件地址 容器内地址。12d7f14v45cv为容器id。docker cp /www/runoob 12d7f14v45cv:/www/ #创建一个新的容器并运行，-d为后台执行，-p 9000:3000前面为主机端口，后面是容器端口。docker_demo镜像名docker run -d -p 9000:3000 docker_demo #启动已被停止的容器docker start docker_demo #关闭已被启动的容器docker stop docker_demo #重新启动容器docker restart docker_demo #杀掉一个运行中的容器。docker kill -s KILL docker_demo #删除一个或多少容器。-f :通过SIGKILL信号强制删除一个运行中的容器-l :移除容器间的网络连接，而非容器本身-v :-v 删除与容器关联的卷docker rm -f docker_demo、docker_demo1 #在运行的容器中执行命令。104e28f2f072容器idsudo docker exec -it 104e28f2f072 /bin/bash #列出容器。 -a:所有容器包含没有运行的docker ps #获取容器获取容器的日志 104e28f2f072容器id，-t:显示时间戳docker logs -f -t 104e28f2f072 #登陆镜像仓库docker login #获取镜像docker pull #上传镜像docker push #查看指定镜像的创建历史。docker history docker_demo","categories":[{"name":"Docker学习","slug":"Docker学习","permalink":"http://yoursite.com/categories/Docker学习/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"Docker学习系列笔记[镜像][容器][仓库]","slug":"docker/Docker学习系列笔记-镜像-容器-仓库","date":"2018-12-13T10:27:46.000Z","updated":"2018-12-21T12:12:06.537Z","comments":true,"path":"2018/12/13/docker/Docker学习系列笔记-镜像-容器-仓库/","link":"","permalink":"http://yoursite.com/2018/12/13/docker/Docker学习系列笔记-镜像-容器-仓库/","excerpt":"","text":"镜像、容器、仓库docker的核心概念————镜像、容器、仓库，docker大部分操作都是围绕这是三个概念做的 镜像(images) Docker的镜像概念类似于虚拟机里的镜像，是一个只读的模板，一个独立的文件系统，包括运行容器所需的数据，可以用来创建新的容器。 容器(container) Docker容器是由Docker镜像创建的运行实例。Docker容器类似虚拟机，可以支持的操作包括启动，停止，删除等。每个容器间是相互隔离的，容器中会运行特定的应用，包含特定应用的代码及所需的依赖文件。 仓库(container) 如果你使用过git和github就很容易理解Docker的仓库概念。Docker 仓库的概念跟Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。 Docker 仓库是用来包含镜像的位置，Docker提供一个注册服务器（Register）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像。Docker运行中使用的默认仓库是 Docker Hub 公共仓库。 仓库支持的操作类似git，当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。 总结 仓库是为镜像托管服务的（类似于Git） 容器是镜像实例化以后的，其中各个容器是相互独立的（类似于类实例化的结果） 镜像是一个只读文件，包含容器所运行的配置文件及数据（类似于类） image","categories":[{"name":"Docker学习","slug":"Docker学习","permalink":"http://yoursite.com/categories/Docker学习/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"Docker学习系列笔记[安装及启动]","slug":"docker/Docker学习系列笔记[安装及启动]","date":"2018-12-13T02:24:33.000Z","updated":"2018-12-21T12:12:08.139Z","comments":true,"path":"2018/12/13/docker/Docker学习系列笔记[安装及启动]/","link":"","permalink":"http://yoursite.com/2018/12/13/docker/Docker学习系列笔记[安装及启动]/","excerpt":"","text":"docker 学习安装及启动 CenOs 1.通过yum安装：在CenOs7安装时，需要先\b添加docker下载源 vi /etc/yum.repo.d/docker.repo 12345678910[dockerrepo] name=Docker Repository baseurl=https://yum.dockerproject.org/repo/main/centos/7/ enabled=1 gpgcheck=1 gpgkey=https://yum.dockerproject.org/gpg 12sudo yum updatesudo yum install -y docker-engine 2.通过脚本安装 1curl -fsSL https://get.docker.com/ | sh 3.启动 1sudo systemctl start docker.service Mac 下载地址 1.需注册后下载 2.启动（\b状态栏icon即可启动）","categories":[{"name":"Docker学习","slug":"Docker学习","permalink":"http://yoursite.com/categories/Docker学习/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"如何搭建自己的技术文档","slug":"如何搭建自己的技术文档","date":"2018-12-12T01:39:36.000Z","updated":"2018-12-12T11:30:26.016Z","comments":true,"path":"2018/12/12/如何搭建自己的技术文档/","link":"","permalink":"http://yoursite.com/2018/12/12/如何搭建自己的技术文档/","excerpt":"","text":"","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"}]}]}