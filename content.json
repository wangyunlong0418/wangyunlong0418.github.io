{"meta":{"title":"鲁西西杂货店","subtitle":null,"description":"鲁西西技术文档","author":"wangyunlong","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2019-06-06T07:37:02.961Z","updated":"2019-06-06T07:37:02.961Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-06-06T07:36:33.521Z","updated":"2019-06-06T07:36:33.521Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"前端知识-2019-6-4","slug":"前端知识集锦/2019-6-4","date":"2019-06-04T10:14:19.000Z","updated":"2019-06-04T10:17:07.257Z","comments":true,"path":"2019/06/04/前端知识集锦/2019-6-4/","link":"","permalink":"http://yoursite.com/2019/06/04/前端知识集锦/2019-6-4/","excerpt":"","text":"","categories":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/categories/前端知识/"}],"tags":[{"name":"前端知识","slug":"前端知识","permalink":"http://yoursite.com/tags/前端知识/"}]},{"title":"构建base Image","slug":"docker/Docker学习笔记-构建base-Image","date":"2019-04-03T04:55:12.000Z","updated":"2019-06-04T10:11:14.874Z","comments":true,"path":"2019/04/03/docker/Docker学习笔记-构建base-Image/","link":"","permalink":"http://yoursite.com/2019/04/03/docker/Docker学习笔记-构建base-Image/","excerpt":"","text":"1.创建hello.js 1console.log(&apos;hello&apos;) 2.创建Dockerfile 123FROM scratch // scratch代表没有baseImageADD hello.js / // 添加到根目录CMD [&quot; node hello.js &quot;] // 执行命令 3.运行build命令 1docker build -t xxx . // -t 表示tag xxx是tag名，.必不可少，表示在当前目录找Dockerfile 如果执行build命令执行成功，则构建成功，可以用dockcer image ls查看。","categories":[{"name":"Docker学习","slug":"Docker学习","permalink":"http://yoursite.com/categories/Docker学习/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"egg-sequelize","slug":"egg/egg-sequelize","date":"2019-03-15T00:10:24.000Z","updated":"2019-06-06T06:55:51.854Z","comments":true,"path":"2019/03/15/egg/egg-sequelize/","link":"","permalink":"http://yoursite.com/2019/03/15/egg/egg-sequelize/","excerpt":"","text":"egg-sequelize在大型应用中，我们可能需要ORM框架来帮助我们管理数据层面工具，而sequelize在node社区中被广泛使用。它支持MySql,PostgreSQL,SQLite,MSSQL等多个数据源。 下面用demo演示如何利用egg-sequelize进行CRUD操作。 初始化项目 12egg-init --type=simple sequelize-demonpm i 配置config（config/config.default.js） 12345678config.sequelize = &#123; port: 3306, dialect: &apos;mysql&apos;, host: &apos;localhost&apos;, database: &apos;miao&apos;, username: &apos;root&apos;, password: &apos;123456&apos;,&#125; 配置插件 plugin.js（config/plugin.js） 1234exports.sequelize = &#123; enable: true, package: ‘egg-sequelize’&#125; 安装egg-sequelize, sequelize-cli, mysql2 1npm i egg-sequelize sequelize-cli mysql2 sequelize配置文件 .sequelizerc 123456789&apos;use strict&apos;;const path = require(&apos;path&apos;);module.exports = &#123; config: path.join(__dirname, &apos;database/config.json&apos;), &apos;migrations-path&apos;: path.join(__dirname, &apos;database/migrations&apos;), // 用来控制数据库迁移的文件夹，需要修改表结构的时候，可以通过代码来控制数据库表结构的版本回退 &apos;seeders-path&apos;: path.join(__dirname, &apos;database/seeders&apos;), // 是存放如何生成假数据的文件夹 &apos;models-path&apos;: path.join(__dirname, &apos;app/models&apos;), // 是表中字段硬度和到JS对象中的逻辑，在controller中和service中可通过this.app.model或者this.ctx.model访问&#125; 初始化 12npx sequelize init:config (生成database目录和配置文件config.json)npx sequelize init:migrations(生成database目录和子目录migrations) 123456789101112131415161718192021222324// config.json&#123; &quot;development&quot;: &#123; &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: &quot;123456&quot;, &quot;database&quot;: &quot;miao&quot;, &quot;host&quot;: &quot;localhost&quot;, &quot;dialect&quot;: &quot;mysql&quot; &#125;, &quot;test&quot;: &#123; &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: &quot;123456&quot;, &quot;database&quot;: &quot;miao&quot;, &quot;host&quot;: &quot;localhost&quot;, &quot;dialect&quot;: &quot;mysql&quot; &#125;, &quot;production&quot;: &#123; &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: &quot;123456&quot;, &quot;database&quot;: &quot;miao&quot;, &quot;host&quot;: &quot;localhost&quot;, &quot;dialect&quot;: &quot;mysql&quot; &#125;&#125; 初始化user表npx sequelize migration:generate --name=init-users, 会在migration生成一个migration 文件(${timestamp}-init-users.js) 12345678910111213141516171819&apos;use strict&apos;;module.exports = &#123; // 在执行数据库升级时调用的函数，创建 users 表 up: async (queryInterface, Sequelize) =&gt; &#123; const &#123; INTEGER, DATE, STRING &#125; = Sequelize; await queryInterface.createTable(&apos;users&apos;, &#123; id: &#123; type: INTEGER, primaryKey: true, autoIncrement: true &#125;, name: STRING(30), age: INTEGER, created_at: DATE, updated_at: DATE, &#125;); &#125;, // 在执行数据库降级时调用的函数，删除 users 表 down: async queryInterface =&gt; &#123; await queryInterface.dropTable(&apos;users&apos;); &#125;,&#125;; 升级数据库npx sequelize db:megrate 1234# 如果有问题需要回滚，可以通过 `db:migrate:undo` 回退一个变更# npx sequelize db:migrate:undo# 可以通过 `db:migrate:undo:all` 回退到初始状态# npx sequelize db:migrate:undo:all 创建model 12345678910111213141516// app/models/user.js&apos;use strict&apos;;module.exports = app =&gt; &#123; const &#123; STRING, INTEGER, DATE &#125; = app.Sequelize; const User = app.model.define(&apos;user&apos;, &#123; id: &#123; type: INTEGER, primaryKey: true, autoIncrement: true &#125;, name: STRING(30), age: INTEGER, created_at: DATE, updated_at: DATE, &#125;); return User;&#125;; 这样就可以在app.model.User或者 ctx.model.User上访问User。12345678910111213141516171819202122232425262728293031323334353637383940414243444546// service/user.js&apos;use strict&apos;;const Service = require(&apos;egg&apos;).Service;class User extends Service &#123; async list(&#123; offset = 0, limit = 10 &#125;) &#123; return this.ctx.model.User.findAndCountAll(&#123; offset, limit, order: [[ &apos;created_at&apos;, &apos;desc&apos; ], [ &apos;id&apos;, &apos;desc&apos; ]], &#125;); &#125; // 查找 async find(id) &#123; const user = await this.ctx.model.User.findById(id); if (!user) &#123; this.ctx.throw(404, &apos;user not found&apos;); &#125; return user; &#125; // 创建 async create(user) &#123; return this.ctx.model.User.create(user); &#125; // 更新 async update(&#123; id, updates &#125;) &#123; const user = await this.ctx.model.User.findById(id); if (!user) &#123; this.ctx.throw(404, &apos;user not found&apos;); &#125; return user.update(updates); &#125; // 删除 async del(id) &#123; const user = await this.ctx.model.User.findById(id); if (!user) &#123; this.ctx.throw(404, &apos;user not found&apos;); &#125; return user.destroy(); &#125;&#125;module.exports = User;","categories":[{"name":"Egg学习笔记","slug":"Egg学习笔记","permalink":"http://yoursite.com/categories/Egg学习笔记/"}],"tags":[{"name":"egg","slug":"egg","permalink":"http://yoursite.com/tags/egg/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"sequelize","slug":"sequelize","permalink":"http://yoursite.com/tags/sequelize/"}]},{"title":"Sequelize 创建数据库表","slug":"egg/sequelize/Sequelize","date":"2019-03-14T23:32:01.000Z","updated":"2019-06-06T06:55:32.850Z","comments":true,"path":"2019/03/15/egg/sequelize/Sequelize/","link":"","permalink":"http://yoursite.com/2019/03/15/egg/sequelize/Sequelize/","excerpt":"","text":"Sequelize类型Sequelize类型有很多，详情DataType。其中常用的有 STRING, TEXT, INTEGER, FLOAT, DOUBLE, DATE等。 环境搭建 创建数据库test_sequelize 1CREATE DATABASE test_sequelize DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; 创建文件夹sequelize，执行npm init; cd sequelize,并执行npm i sequelize mysql2; 创建以下文件夹 app/model app/db app/utils \b创建连接1234567891011121314151617181920212223242526// db/index.jsconst Sequelize = requeire(&apos;sequelize&apos;);const dbconfig = &#123; username: &apos;root&apos;, // mysql用户名 password: &apos;root&apos;, // mysql 密码 database: &apos;sequelize_test&apos;, // 数据库名 port: 3306, host: &apos;localhost&apos;, dialect: &apos;mysql&apos; // &apos;mysql&apos;|&apos;sqlite&apos;|&apos;postgres&apos;|&apos;mssql&apos;&#125;const &#123; username, password, database, port, host, dialect &#125; = dbconfig;const db = new Sequelize(database, username, password, &#123; host, port, dialect, pool: &#123; max: 5, min: 0, idle: 100000 &#125;, timezone: &apos;+08:00&apos; // 时区&#125;)module.exports = db; ### 创建表12345678910111213141516171819202122232425const Sequelize = requeire(&apos;sequelize&apos;);const &#123; STRING, INTEGER &#125; = Sequelize;const db = require(&apos;../db&apos;);const User = db.define(&apos;user&apos;, &#123; // 表名 userId: &#123; type: INTEGER &#125;, userName: &#123; type: STRING &#125;, password: &#123; type: STRING &#125;,&#125;)const createTable = () =&gt; &#123; await User.sync(&#123; force: false // 设置为true，则先删除在创建 &#125;)&#125;(async () =&gt; &#123; await createTable()&#125;)()","categories":[{"name":"Egg学习笔记","slug":"Egg学习笔记","permalink":"http://yoursite.com/categories/Egg学习笔记/"}],"tags":[{"name":"egg","slug":"egg","permalink":"http://yoursite.com/tags/egg/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"sequelize","slug":"sequelize","permalink":"http://yoursite.com/tags/sequelize/"}]},{"title":"Flutter介绍","slug":"flutter/Flutter介绍","date":"2019-01-31T10:10:06.000Z","updated":"2019-06-04T10:24:58.430Z","comments":true,"path":"2019/01/31/flutter/Flutter介绍/","link":"","permalink":"http://yoursite.com/2019/01/31/flutter/Flutter介绍/","excerpt":"","text":"1.移动开发技术简介移动开发技术简介 2.Flutter简介Flutter是谷歌公司推出的一个移动应用开发框架，主要有跨平台、高保真、高性能等优点。基于dart语言开发，可以一套代码分别运行在IOS和Android平台上。Flutter有丰富的组件\b和接口。 3.资源 官网 Flutter中文网 4.搭建开发环境https://book.flutterchina.club/chapter1/install_flutter.html","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/categories/Flutter/"}],"tags":[{"name":"移动端 Flutter","slug":"移动端-Flutter","permalink":"http://yoursite.com/tags/移动端-Flutter/"}]},{"title":"Electron[第一个Electron应用","slug":"electron/Electron-第一个Electron应用","date":"2018-12-21T13:05:40.000Z","updated":"2018-12-21T13:05:45.062Z","comments":true,"path":"2018/12/21/electron/Electron-第一个Electron应用/","link":"","permalink":"http://yoursite.com/2018/12/21/electron/Electron-第一个Electron应用/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Electron快速开始","slug":"electron/Electron[快速开始]","date":"2018-12-21T12:15:01.000Z","updated":"2018-12-25T08:58:33.892Z","comments":true,"path":"2018/12/21/electron/Electron[快速开始]/","link":"","permalink":"http://yoursite.com/2018/12/21/electron/Electron[快速开始]/","excerpt":"","text":"Electron 介绍 比你想象的更简单—对于前端人员，electron可以帮助其构建桌面应用，Electron文档上写道，只要你会写html，css，js就可以，剩下的事情交给Electron去做 快速开始12345git clone https://github.com/electron/electron-quick-startcd electron-quick-start npm install &amp; npm start 这个时候你就应该可以看到一个hello world","categories":[{"name":"Electron学习","slug":"Electron学习","permalink":"http://yoursite.com/categories/Electron学习/"}],"tags":[{"name":"Electron","slug":"Electron","permalink":"http://yoursite.com/tags/Electron/"}]},{"title":"Docker学习笔记-镜像","slug":"docker/Docker学习笔记-镜像","date":"2018-12-16T10:35:59.000Z","updated":"2019-06-04T11:24:29.701Z","comments":true,"path":"2018/12/16/docker/Docker学习笔记-镜像/","link":"","permalink":"http://yoursite.com/2018/12/16/docker/Docker学习笔记-镜像/","excerpt":"","text":"镜像 获取镜像 Docker Hub为开发者提供了数十万的镜像，可以为大家下载 可以通过 docker pull [NAME]:[TAG], TAG如果不指定的话，会默认去拉取tag为latest的镜像，也就是最新版, docker pull可以修改下载仓库，切换到自己的私有仓库， 1docker pull xxx(私有仓库地址) docker pull 子命令 1docker pull -a --all-tags=true | false 查看镜像信息 docker images images REPOSITORY: 镜像来自于哪个仓库 TAG: 镜像标签信息 IMAGE ID: 镜像唯一ID CREATED: 创建时间，最后更新时间 SIZE: 镜像大小(一般来说，越小越好) 发布一个镜像","categories":[{"name":"Docker学习","slug":"Docker学习","permalink":"http://yoursite.com/categories/Docker学习/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"Docker学习系列笔记[docker常用命令]","slug":"docker/Docker学习系列笔记-docker常用命令","date":"2018-12-14T04:01:44.000Z","updated":"2018-12-21T12:12:05.083Z","comments":true,"path":"2018/12/14/docker/Docker学习系列笔记-docker常用命令/","link":"","permalink":"http://yoursite.com/2018/12/14/docker/Docker学习系列笔记-docker常用命令/","excerpt":"","text":"#查看当前docker版本docker -v #查看当前本地所有镜像docker images #构造镜像,用法docker build -t 镜像名称 .docker build -t docker_demo . #用于容器与主机之间的数据拷贝。用法docker cp 主机文件地址 容器内地址。12d7f14v45cv为容器id。docker cp /www/runoob 12d7f14v45cv:/www/ #创建一个新的容器并运行，-d为后台执行，-p 9000:3000前面为主机端口，后面是容器端口。docker_demo镜像名docker run -d -p 9000:3000 docker_demo #启动已被停止的容器docker start docker_demo #关闭已被启动的容器docker stop docker_demo #重新启动容器docker restart docker_demo #杀掉一个运行中的容器。docker kill -s KILL docker_demo #删除一个或多少容器。-f :通过SIGKILL信号强制删除一个运行中的容器-l :移除容器间的网络连接，而非容器本身-v :-v 删除与容器关联的卷docker rm -f docker_demo、docker_demo1 #在运行的容器中执行命令。104e28f2f072容器idsudo docker exec -it 104e28f2f072 /bin/bash #列出容器。 -a:所有容器包含没有运行的docker ps #获取容器获取容器的日志 104e28f2f072容器id，-t:显示时间戳docker logs -f -t 104e28f2f072 #登陆镜像仓库docker login #获取镜像docker pull #上传镜像docker push #查看指定镜像的创建历史。docker history docker_demo","categories":[{"name":"Docker学习","slug":"Docker学习","permalink":"http://yoursite.com/categories/Docker学习/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"Docker学习系列笔记[镜像][容器][仓库]","slug":"docker/Docker学习系列笔记-镜像-容器-仓库","date":"2018-12-13T10:27:46.000Z","updated":"2018-12-21T12:12:06.537Z","comments":true,"path":"2018/12/13/docker/Docker学习系列笔记-镜像-容器-仓库/","link":"","permalink":"http://yoursite.com/2018/12/13/docker/Docker学习系列笔记-镜像-容器-仓库/","excerpt":"","text":"镜像、容器、仓库docker的核心概念————镜像、容器、仓库，docker大部分操作都是围绕这是三个概念做的 镜像(images) Docker的镜像概念类似于虚拟机里的镜像，是一个只读的模板，一个独立的文件系统，包括运行容器所需的数据，可以用来创建新的容器。 容器(container) Docker容器是由Docker镜像创建的运行实例。Docker容器类似虚拟机，可以支持的操作包括启动，停止，删除等。每个容器间是相互隔离的，容器中会运行特定的应用，包含特定应用的代码及所需的依赖文件。 仓库(container) 如果你使用过git和github就很容易理解Docker的仓库概念。Docker 仓库的概念跟Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。 Docker 仓库是用来包含镜像的位置，Docker提供一个注册服务器（Register）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像。Docker运行中使用的默认仓库是 Docker Hub 公共仓库。 仓库支持的操作类似git，当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。 总结 仓库是为镜像托管服务的（类似于Git） 容器是镜像实例化以后的，其中各个容器是相互独立的（类似于类实例化的结果） 镜像是一个只读文件，包含容器所运行的配置文件及数据（类似于类） image","categories":[{"name":"Docker学习","slug":"Docker学习","permalink":"http://yoursite.com/categories/Docker学习/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"Docker学习系列笔记[安装及启动]","slug":"docker/Docker学习系列笔记[安装及启动]","date":"2018-12-13T02:24:33.000Z","updated":"2018-12-21T12:12:08.139Z","comments":true,"path":"2018/12/13/docker/Docker学习系列笔记[安装及启动]/","link":"","permalink":"http://yoursite.com/2018/12/13/docker/Docker学习系列笔记[安装及启动]/","excerpt":"","text":"docker 学习安装及启动 CenOs 1.通过yum安装：在CenOs7安装时，需要先\b添加docker下载源 vi /etc/yum.repo.d/docker.repo 12345678910[dockerrepo] name=Docker Repository baseurl=https://yum.dockerproject.org/repo/main/centos/7/ enabled=1 gpgcheck=1 gpgkey=https://yum.dockerproject.org/gpg 12sudo yum updatesudo yum install -y docker-engine 2.通过脚本安装 1curl -fsSL https://get.docker.com/ | sh 3.启动 1sudo systemctl start docker.service Mac 下载地址 1.需注册后下载 2.启动（\b状态栏icon即可启动）","categories":[{"name":"Docker学习","slug":"Docker学习","permalink":"http://yoursite.com/categories/Docker学习/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"如何搭建自己的技术文档","slug":"如何搭建自己的技术文档","date":"2018-12-12T01:39:36.000Z","updated":"2018-12-12T11:30:26.016Z","comments":true,"path":"2018/12/12/如何搭建自己的技术文档/","link":"","permalink":"http://yoursite.com/2018/12/12/如何搭建自己的技术文档/","excerpt":"","text":"","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/categories/学习笔记/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://yoursite.com/tags/node-js/"}]}]}